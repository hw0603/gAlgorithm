# Info
[26259 백룸](https://www.acmicpc.net/problem/26259)

## 💡 풀이 방법 요약
BFS + 캐싱(DP) 로 풀이한다.

벽이 가로로 주어질 수도 있고 세로로 주어질 수도 있으니,  
시작점과 끝점을 가지고 판단해서 특정 칸에서 벽 때문에 이동할 수 없는 방향이 있을 경우 미리 마킹해 둔다.

이후 단순 BFS를 적용하면 정답은 도출할 수 있지만, 의미 없는 BFS 가지가 너무 많아져서 TLE를 맞는다.

즉, 시간을 줄이기 위해서는 의미 없는 가지(최댓값이 될 수 없는 경우)를 미리 종료시켜 줘야 하는데, 생각해 보면 벽을 고려하지 않았을 때 특정 좌표는 최대 두 곳(왼쪽, 위)에서밖에 도달하지 못한다.

> 간단한 캐싱 아이디어: 각 좌표를 기준으로 첫 방문 시에는 캐시에 값을 저장해 두고, 두 번째 방문 시 캐시값과 현재 값을 비교하여 큰 값만을 큐에 추가한다!

이렇게 구현할 경우, 아래의 상황에 대해 잘 처리해 줘야 한다.  
1. 벽 때문에 한 번 밖에 방문하지 못하는 곳
2. 벽 때문에 전혀 방문하지 못하는 곳
3. 0행과 0열 (각각 윗칸과 왼쪽 칸이 없으므로 1회 방문 시 바로 큐에 추가해야 함)

1번과 3번의 경우 미리 `음의 무한대 값` 으로 캐시값을 남겨 두면 간단히 해결되는데, 2번의 경우 생각이 조금 필요하다.

![image](https://github.com/hw0603/gAlgorithm/assets/31981462/3bc224dd-33c1-4ebb-9679-58d9cb88bc47)
빨간 벽과 초록 벽은 `1`번 경우, 보라 벽은 `2`번 경우로 볼 수 있다.  
보라색 벽과 같이 벽이 최상단 혹은 최좌단부터 시작할 경우, 보라색 x표 영역은 전혀 방문할 수 없는 영역으로 남게 된다.  
따라서 이의 영향을 고려하여 보라색으로 색칠된 부분 역시 캐시값을 `음의 무한대 값`으로 초기화해 주어야 한다.

## 👀 실패 이유
벽 좌표 정렬을 잘못했다.. 벽이 세로로 주어질 수도 있는 것을 미리 인지했지만, 정렬에서 신경을 전혀 못 쓰고 있었다.
```python
x1, y1, x2, y2 = map(int, sys.stdin.readline().split())

# 정답
x1, x2, y1, y2 = min(x1, x2), max(x1, x2), min(y1, y2), max(y1, y2)

# 오답
x1, y1 = min((x1, y1), (x2, y2))
x2, y2 = max((x1, y1), (x2, y2))
```

## 🙂 마무리

