# IF문 좀 대신 써줘

https://www.acmicpc.net/problem/19637

if 문 정도는 직접 좀 하지...

## 입력 조건

칭호의 개수 $ N (1 ≤ N ≤ 10^5)$
칭호를 출력해야 하는 캐릭터들의 개수 $ M (1 ≤ M ≤ 10^5)$ 

칭호의 전투력 상한 값 : $ 10^9 $ 이하의 음이 아닌 정수

해당하는 칭호가 없는 전투력은 입력으로 주어지지 않는다.

## 풀이

제한 시간이 1초이고 언어별 추가 시간도 없기 때문에 빡빡한 단순히 구현만 하는 문제는 아니었다. $ O(M * N) $ 보다 더 작은 시간이 걸려야 했다. 

또한, 각 캐릭터 마다 판단을 해야 하므로 $ O(M) $ 이상의 시간이 걸린다는 것이 명확했다. 즉, 특정 캐릭터의 칭호를 판단하는 과정이 상수 시간 혹은 로그 시간이 걸려야 했다. 

칭호의 전투력 상한 값의 범위가 $ 10^9 $ 이므로 이를 이용해 Set 을 만든다 해도 시간 초과가 자명했다. 칭호가 정렬되어있다는 점을 이용해 이분탐색을 이용할 수 있겠다는 생각이 들었다.

찾아야 하는 것은 "기준 값 이상이면서 가장 왼쪽에 있는 것의 위치"다. 따라서 이분 탐색에서 중간 값이 기준 값보다 작으면 시작 위치를 중간 바로 다음으로 이동하는 것은 그대로라 생각했다. 반대로 기준 값보다 크면 끝 위치를 중간 바로 이전으로 이동하는 것도 그대로라 생각했다. 그런데, 기준 값과 중간 값이 같은 경우 어떻게 해야 하는지 생각이 나지 않았다.

몇번의 시뮬레이션 중, 최종적으로 끝 값이 기준 값 미만이면서 가장 오른쪽에 있게 할 수 있다면, 끝 값에서 1을 더해 반환하여 찾을 수 있음을 알았다. 그러기 위해서는 기준값과 중간 값이 같은 경우 끝 위치를 중간 바로 이전으로 이동하게 할 필요가 있었다.

```Java
private static int bs(List<Integer> list, int value) {
    int start = 0;
    int end = list.size() - 1;
    while (start <= end) {
        int mid = (start + end) / 2;
        if (list.get(mid) < value) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    return end + 1;
}
```