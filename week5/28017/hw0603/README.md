# Info
[28017 게임을 클리어하자](https://www.acmicpc.net/problem/28017)

## 💡 풀이 방법 요약
`dp[i][j] = i번째 라운드에서 j번째 무기를 선택했을 때 최적 값` 으로 정의하면,  
매 라운드에서 선택지 별 최적값은 직전 라운드의 최적 값들 중 최솟값 + 선택한 무기 값이 된다.  
즉, `dp[i+1][j] = min(dp[i]) + currentWeapon` 이 성립한다.  

이때, 문제 조건에 의해 현재의 선택지가 이전에 선택된(최솟값) 인덱스의 무기와 겹친다면, 직전 라운드의 두 번째 최적 값을 사용해야 한다.

실제로 `dp` 테이블을 참조할 때는 바로 직전의 행만 참조하므로, 1차원 리스트 두개를 두고 루프 내에서 리스트 자체를 업데이트하며 구현했다.


## 👀 실패 이유
문제를 잘못 이해해서 단순히 이전 최솟값의 인덱스랑 겹치지만 않으면 되는 줄 알고 `heapq`로 접근했었다.

## 🙂 마무리
그냥 2차원 리스트로 dp를 만들었어도 됐을 듯.  
두 번째 최적값을 가져오는 부분(정렬 후 `[1]` 로 가져오는 부분)은 개선이 가능할 것 같은데 일단 그냥 둠
