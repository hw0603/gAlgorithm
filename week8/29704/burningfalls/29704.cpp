#include <bits/stdc++.h>
using namespace std;

// 그 유명한 배낭 문제(knapsack)입니다.
// dp 중에서도 너무 유형이 뚜렷해서 따로 떨어져 나온 느낌입니다. (마치 누적합 같이)
// dp를 구현하는 방법은 총 두 가지가 있습니다. (1. 반복문, 2. 재귀)
// 배낭 문제도 마찬가지로 반복문과 재귀로 풀 수 있지만, 장단점이 있습니다.
// 반복문으로 푸는 경우 -> 이해만 하면 굉장히 직관적이다. 머리가 이해를 거부한다. 문제 유형이 바뀌었을 때, 인덱스를 응용하는게 상당히 까다롭다.(재귀는 걱정 안해도 됨)
// 재귀로 푸는 경우 -> 정해진 틀에 코드를 끼워맞추기만 하면 돼서 구현이 단순하다. 코드가 잘 굴러갈 것이라는 믿음만으로, 로직 이해 없이 코드 구현이 가능하다. 대신 로직이 틀렸을 때 디버깅(눈디버깅이든 손디버깅이든)이 굉장히 힘들다.
// 배낭 문제는 한 번쯤 각잡고 공부해보세요. 전체적인 상향평준화로 인해서 코테에서도 스멀스멀 보이는 친구입니다. dp의 이해가 선행되어야 쉽습니다.
int main() {
    int N, T;
    cin >> N >> T;
    vector<pair<int, int>> v(N);
    int sum = 0;
    for(int i = 0; i < N; i++) {
        cin >> v[i].first >> v[i].second;
        sum += v[i].second;
    }
    
    vector<int> dp(T + 1, -1);
    dp[0] = 0;
    for(int i = 0; i < N; i++) {
        int d = v[i].first;
        int m = v[i].second;
        
        // 하나의 문제에 대해서 전체 경우의 수를 탐색합니다.
        // 걸리는 총 일수가 T인 경우, 걸리는 총 일수가 T-1인 경우, ...
        // 걸리는 총 일수가 2인 경우, 걸리는 총 일수가 1인 경우
        // 걸리는 총 일수가 현재 j라면, 이는 걸리는 총 일수가 j-d일 일때, 이 문제를 푼 것입니다.
        // 역방향으로 탐색하는 이유는, 한 번의 반복문에서(하나의 문제에 대해서) 갱신한 값을 또 갱신(하나의 문제를 두 번 사용)해버리기 때문입니다.
        for(int j = T; j >= d; j--) {
            // j-d일의 정보가 존재하지 않으면, j일이 되는 것이 불가능하므로 값을 갱신해서는 안됩니다.
            if (dp[j - d] == -1) continue;
            
            dp[j] = max(dp[j], dp[j - d] + m);
        }
    }
    
    // 걸리는 총 일수가 0~T일 때, 해결한 문제의 벌금 합의 최댓값을 구합니다.
    int maxi = 0;
    for(int i = 0; i <= T; i++) {
        maxi = max(maxi, dp[i]);
    }
    
    // 전체 돈 - 해결한 문제의 벌금 합 = 해결하지 못한 문제의 벌금 합
    cout << sum - maxi << "\n";
    
    return 0;
}
